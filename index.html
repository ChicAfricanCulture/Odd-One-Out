<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spice Interference ‚Äî African Spices</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #0f1720;
    }

    .wrap {
      height: 100%;
      width: min(520px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
    }

    .hud {
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(15, 23, 32, 0.08);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
    }
    .hud-left { display: grid; gap: 2px; }
    .title {
      font-weight: 1000;
      letter-spacing: 0.2px;
      font-size: 14px;
      line-height: 1.1;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.2;
    }
    .hud-right {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      background: rgba(15, 23, 32, 0.06);
      border: 1px solid rgba(15, 23, 32, 0.10);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
    }
    .pill strong { font-weight: 1000; }

    .stage {
      flex: 1 1 auto;
      min-height: 0;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: manipulation;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(255,255,255,0.70);
      z-index: 20;
    }
    .overlay.show { display: flex; }

    .card {
      width: min(520px, 100%);
      background: #ffffff;
      border: 1px solid rgba(15, 23, 32, 0.10);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.12);
    }
    .card h1 {
      margin: 0 0 8px;
      font-size: 18px;
      line-height: 1.15;
      font-weight: 1000;
    }
    .card p {
      margin: 0 0 12px;
      line-height: 1.45;
      font-size: 13px;
      opacity: 0.9;
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 1000;
      cursor: pointer;
      background: #0f1720;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    .flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: rgba(231, 76, 60, 0.12);
      opacity: 0;
      transition: opacity 120ms ease;
      z-index: 5;
    }
    .flash.show { opacity: 1; }

    .scent-message {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: #0f1720;
      color: white;
      padding: 10px 18px;
      border-radius: 40px;
      font-size: 14px;
      font-weight: 700;
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10;
      max-width: calc(100% - 24px);
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .scent-message.show { opacity: 1; }

    .hint {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.78;
      text-align: center;
      pointer-events: none;
      z-index: 2;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="hud-left">
        <div class="title">Spice Interference ‚Äî African Spices</div>
        <div class="subtitle" id="hudSubtitle">Level 1</div>
      </div>
      <div class="hud-right">
        <div class="pill">‚è≥ <strong id="timeVal">‚Äî</strong></div>
        <div class="pill">üéØ Left: <strong id="leftVal">‚Äî</strong></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="flash" id="flash"></div>
      <div class="scent-message" id="scentMessage"></div>

      <div class="overlay show" id="startOverlay">
        <div class="card">
          <h1 id="startTitle">Level 1</h1>
          <p id="startDesc"></p>
          <div class="btnRow">
            <button id="beginBtn" type="button">Start</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="endOverlay">
        <div class="card">
          <h1 id="endTitle">Done</h1>
          <p id="endText"></p>
          <div class="btnRow">
            <button id="nextBtn" type="button">Next Level</button>
            <button id="restartBtn" type="button">Replay Level</button>
          </div>
        </div>
      </div>

      <div class="hint" id="hint">Tap the correct spice before time runs out.</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);

  const hudSubtitle = document.getElementById("hudSubtitle");
  const timeVal = document.getElementById("timeVal");
  const leftVal = document.getElementById("leftVal");

  const startOverlay = document.getElementById("startOverlay");
  const startTitle = document.getElementById("startTitle");
  const startDesc = document.getElementById("startDesc");

  const endOverlay = document.getElementById("endOverlay");
  const endTitle = document.getElementById("endTitle");
  const endText = document.getElementById("endText");

  const flash = document.getElementById("flash");
  const scentMessage = document.getElementById("scentMessage");
  const hint = document.getElementById("hint");

  const beginBtn = document.getElementById("beginBtn");
  const nextBtn = document.getElementById("nextBtn");
  const restartBtn = document.getElementById("restartBtn");

  function rand(a, b) { return Math.random() * (b - a) + a; }
  function randi(a, b) { return Math.floor(rand(a, b + 1)); }
  function pick(arr) { return arr[randi(0, arr.length - 1)]; }

  function flashWrong() {
    flash.classList.add("show");
    setTimeout(() => flash.classList.remove("show"), 120);
  }

  let scentTimer = null;
  function showScentMessage(text) {
    scentMessage.textContent = text;
    scentMessage.classList.add("show");
    if (scentTimer) clearTimeout(scentTimer);
    scentTimer = setTimeout(() => scentMessage.classList.remove("show"), 1400);
  }

  // Your spice list (kept)
  const SPICE_LIST = [
    "SALT", "GINGER", "BERBERE", "HARISSA", "MITMITA",
    "TURMERIC", "CLOVE", "UDA", "PIRI PIRI", "MAGGIE", "CUBEB"
  ];

  // Canonical ‚Äúspice colors‚Äù (only used when color matters)
  const SPICE_CANON_COLORS = {
    "BERBERE":  "#B31217", // deep red
    "HARISSA":  "#D35400", // orange
    "MITMITA":  "#7D1F1F", // dark red/brown
    "TURMERIC": "#D4AC0D", // golden yellow
    "GINGER":   "#A97142", // ginger brown
    "CLOVE":    "#3B2F2F",
    "UDA":      "#2E4053",
    "PIRI PIRI":"#C0392B",
    "MAGGIE":   "#B7950B",
    "CUBEB":    "#1F2D3A",
    "SALT":     "#7F8C8D"
  };

  // Scent banks (targets have richer lists)
  const TARGET_SCENTS = {
    "BERBERE": [
      "smoky ‚Äî fire and dried chiles",
      "warm ‚Äî clove under the heat",
      "deep ‚Äî red you can almost see",
      "earthy ‚Äî slow burn on the tongue",
      "complex ‚Äî every bite changes",
      "memory ‚Äî Ethiopia in the air"
    ],
    "HARISSA": [
      "fiery ‚Äî roasted peppers rising",
      "garlic ‚Äî deep and pungent",
      "bright ‚Äî lemon and heat together",
      "sticky ‚Äî oil and pepper paste",
      "north ‚Äî warm spice in a jar",
      "toast ‚Äî charred pepper sweetness"
    ],
    "MITMITA": [
      "sharp ‚Äî hot and immediate",
      "spiced ‚Äî cardamom flashes first",
      "deep ‚Äî clove then heat",
      "dry ‚Äî powder that bites",
      "Ethiopia ‚Äî lamb and heat",
      "sting ‚Äî nose wake-up"
    ]
  };

  // Generic scents for distractors (still flavorful)
  const SPICE_SCENTS = {
    "SALT": ["clean ‚Äî ocean air", "simple ‚Äî but essential", "sharp ‚Äî makes you thirsty"],
    "GINGER": ["sharp ‚Äî stings the nose", "warm ‚Äî almost lemony", "peppery ‚Äî alive"],
    "TURMERIC": ["earthy ‚Äî yellow stain", "bitter ‚Äî slightly musty", "warm ‚Äî golden milk"],
    "CLOVE": ["numbing ‚Äî medicinal", "sweet ‚Äî then sharp", "holiday ‚Äî in the air"],
    "UDA": ["musky ‚Äî like perfume", "smoky ‚Äî grains of selim", "peppery ‚Äî a twist"],
    "PIRI PIRI": ["citrus ‚Äî then fire", "bright ‚Äî makes you sweat", "clean heat ‚Äî sharp"],
    "MAGGIE": ["umami ‚Äî salty", "childhood ‚Äî in stew", "crumbled ‚Äî in the pot"],
    "CUBEB": ["peppery ‚Äî perfumed", "woody ‚Äî old cabinet", "sharp ‚Äî then fades"],
    "BERBERE": ["smoky ‚Äî red heat", "warm ‚Äî layered", "deep ‚Äî spice cloud"],
    "HARISSA": ["pepper paste ‚Äî fiery", "garlic heat ‚Äî thick", "bright ‚Äî roasted"],
    "MITMITA": ["sting ‚Äî immediate", "dry heat ‚Äî powder", "spiced ‚Äî sharp"]
  };

  // Level progression as you described
  // 1: BW, find BERBERE (build association)
  // 2: BW, new target HARISSA
  // 3: Color noise (colors irrelevant), target is word
  // 4: Color matters (correct word AND correct canonical color)
  // 5: Faster + colors shift
  // 6: Max chaos + target changes without warning
  const LEVELS = [
    {
      name: "Level 1",
      target: "BERBERE",
      mode: "bwWord", // black and white word only
      seconds: 35,
      targetCount: 5,
      totalWords: 14,
      speed: 1.0,
      colorShift: false,
      targetSwitch: false
    },
    {
      name: "Level 2",
      target: "HARISSA",
      mode: "bwWord",
      seconds: 35,
      targetCount: 5,
      totalWords: 14,
      speed: 1.05,
      colorShift: false,
      targetSwitch: false
    },
    {
      name: "Level 3",
      target: "MITMITA",
      mode: "colorNoiseWord", // colored words, but color irrelevant
      seconds: 32,
      targetCount: 6,
      totalWords: 16,
      speed: 1.15,
      colorShift: false,
      targetSwitch: false
    },
    {
      name: "Level 4",
      target: "BERBERE",
      mode: "wordPlusColor", // must be word AND correct color
      seconds: 30,
      targetCount: 6,
      totalWords: 16,
      speed: 1.25,
      colorShift: false,
      targetSwitch: false
    },
    {
      name: "Level 5",
      target: "HARISSA",
      mode: "wordPlusColor",
      seconds: 28,
      targetCount: 7,
      totalWords: 18,
      speed: 1.35,
      colorShift: true,       // colors shift mid-round
      targetSwitch: false
    },
    {
      name: "Level 6",
      target: "MITMITA",
      mode: "wordPlusColor",
      seconds: 26,
      targetCount: 7,
      totalWords: 20,
      speed: 1.55,
      colorShift: true,
      targetSwitch: true      // target changes without warning
    }
  ];

  let levelIndex = 0;
  let cfg = LEVELS[levelIndex];

  // game state
  let mode = "start"; // start | playing | end
  let tiles = [];
  let lastTs = 0;

  let timeLeft = 0;
  let targetsLeft = 0;
  let currentTarget = ""; // may change in level 6
  let targetSwitchTimer = 0;
  let colorShiftTimer = 0;

  // visual colors for text (for color noise / color correctness)
  const NOISE_COLORS = [
    "#111111", "#2C3E50", "#B31217", "#D35400", "#1F618D",
    "#117A65", "#7D3C98", "#B7950B", "#7F8C8D"
  ];

  function setStartCard() {
    cfg = LEVELS[levelIndex];
    currentTarget = cfg.target;

    startTitle.textContent = `${cfg.name}`;
    const descLines = [];

    if (cfg.mode === "bwWord") {
      descLines.push(`<strong>${currentTarget}.</strong> Black & white. Only the word matters.`);
    } else if (cfg.mode === "colorNoiseWord") {
      descLines.push(`<strong>${currentTarget}.</strong> Words are colored, but color is noise. Only the word matters.`);
    } else if (cfg.mode === "wordPlusColor") {
      descLines.push(`<strong>${currentTarget}.</strong> Now color matters too: the word must be the right spice color.`);
    }

    descLines.push(`Time: <strong>${cfg.seconds}s</strong>. Targets: <strong>${cfg.targetCount}</strong>.`);
    if (cfg.colorShift) descLines.push(`‚ö†Ô∏è Colors will shift mid-round.`);
    if (cfg.targetSwitch) descLines.push(`‚ö†Ô∏è Target will change without warning.`);

    descLines.push(`<br><strong>Each correct target shows a scent memory.</strong>`);

    startDesc.innerHTML = descLines.join("<br>");
    hint.textContent = cfg.mode === "wordPlusColor"
      ? `Tap ${currentTarget} in its correct color.`
      : `Tap ${currentTarget}. Ignore the others.`;
  }

  function setHUD() {
    hudSubtitle.textContent = `${cfg.name}: Find ${currentTarget}${cfg.mode === "wordPlusColor" ? " (and match color)" : ""}`;
    timeVal.textContent = `${Math.ceil(timeLeft)}s`;
    leftVal.textContent = String(targetsLeft);
  }

  class WordTile {
    constructor(x, y, fontSize, vx, vy, text, isTarget, displayColor) {
      this.x = x; this.y = y;
      this.fontSize = fontSize;
      this.vx = vx; this.vy = vy;
      this.text = text;
      this.isTarget = isTarget;
      this.displayColor = displayColor;

      this.alive = true;
      this.popping = false;
      this.popT = 0;

      // aging/fade only in level 1/2/3 to create urgency without rule flips
      this.age = 0;           // 0..1
      this.ageRate = rand(0.25, 0.65) / 100;
    }

    _setFont() {
      ctx.font = `900 ${this.fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    }

    hit(px, py) {
      this._setFont();
      const metrics = ctx.measureText(this.text);
      const width = metrics.width;
      const height = this.fontSize * 1.2;

      const left = this.x - width/2;
      const right = this.x + width/2;
      const top = this.y - height/2;
      const bottom = this.y + height/2;

      // generous hitbox padding
      const pad = 8;
      return px >= left - pad && px <= right + pad && py >= top - pad && py <= bottom + pad;
    }

    pop() {
      if (!this.alive || this.popping) return;
      this.popping = true;
      this.popT = 0;
    }

    update(dt, width, height, speedMul=1) {
      if (!this.alive) return;

      if (this.popping) {
        this.popT += dt * 3.2;
        if (this.popT >= 1) this.alive = false;
        return;
      }

      // age/fade mechanic: only in early levels (makes ‚Äúword attention‚Äù matter)
      const useAging = (levelIndex <= 2); // levels 1‚Äì3
      if (useAging && this.isTarget) {
        this.age = Math.min(1, this.age + this.ageRate * dt * 30);
      }

      // movement
      this.x += this.vx * dt * speedMul;
      this.y += this.vy * dt * speedMul;

      // bounce based on measured text box
      this._setFont();
      const metrics = ctx.measureText(this.text);
      const tw = metrics.width;
      const th = this.fontSize * 1.2;
      const pad = 10;

      if (this.x - tw/2 < pad) { this.x = pad + tw/2; this.vx *= -1; }
      if (this.x + tw/2 > width - pad) { this.x = width - pad - tw/2; this.vx *= -1; }
      if (this.y - th/2 < pad) { this.y = pad + th/2; this.vy *= -1; }
      if (this.y + th/2 > height - pad) { this.y = height - pad - th/2; this.vy *= -1; }
    }

    draw(ctx) {
      if (!this.alive) return;

      let scale = 1, alpha = 1;
      if (this.popping) {
        const t = Math.min(1, this.popT);
        scale = 1 - t * 0.9;
        alpha = 1 - t;
      }

      ctx.save();
      // targets fade slightly as they age (early levels)
      const fade = this.isTarget ? (1 - this.age * 0.55) : 1;
      ctx.globalAlpha = alpha * fade;

      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);

      // choose color based on level mode
      let color = "#222";
      if (cfg.mode === "bwWord") {
        color = this.isTarget ? "rgb(25,25,25)" : "rgb(40,40,40)";
        // targets slowly lighten as they age (subtle)
        if (this.isTarget) {
          const g = Math.floor(25 + this.age * 160);
          color = `rgb(${g},${g},${g})`;
        }
      } else {
        // colored modes
        color = this.displayColor || "#222";
      }

      ctx.fillStyle = color;
      ctx.font = `900 ${this.fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(this.text, 0, 0);

      ctx.restore();
    }
  }

  function spawnTiles() {
    const rect = canvas.getBoundingClientRect();
    const width = rect.width, height = rect.height;

    const targetCount = cfg.targetCount;
    const totalWords = cfg.totalWords;

    // build list with targets + distractors
    const list = [];
    for (let i = 0; i < targetCount; i++) list.push(currentTarget);

    const distractors = SPICE_LIST.filter(s => s !== currentTarget);
    while (list.length < totalWords) list.push(pick(distractors));

    // shuffle
    for (let i = list.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [list[i], list[j]] = [list[j], list[i]];
    }

    const newTiles = list.map(text => {
      const isTarget = (text === currentTarget);
      const fontSize = rand(26, 44);
      const x = rand(fontSize, width - fontSize);
      const y = rand(fontSize + 10, height - fontSize - 10);

      const angle = rand(0, Math.PI * 2);
      const speed = rand(26, 42); // base speed; cfg.speed will multiply
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      // determine display color
      let displayColor = "#222";
      if (cfg.mode === "bwWord") {
        displayColor = "#222";
      } else if (cfg.mode === "colorNoiseWord") {
        // random colors: noise, irrelevant
        displayColor = pick(NOISE_COLORS);
      } else if (cfg.mode === "wordPlusColor") {
        if (isTarget) {
          // correct canonical color for the spice
          displayColor = SPICE_CANON_COLORS[text] || "#B31217";
        } else {
          // distractors: either canonical or random, varies by level
          // in L5/L6 we want more confusion, so randomize more often
          const chaos = (levelIndex >= 4);
          displayColor = chaos ? pick(NOISE_COLORS) : (SPICE_CANON_COLORS[text] || pick(NOISE_COLORS));
        }
      }

      return new WordTile(x, y, fontSize, vx, vy, text, isTarget, displayColor);
    });

    // draw targets on top (reduces hiding frustration)
    tiles = [...newTiles.filter(t => !t.isTarget), ...newTiles.filter(t => t.isTarget)];
  }

  function beginLevel() {
    resizeCanvas();
    cfg = LEVELS[levelIndex];
    mode = "playing";

    timeLeft = cfg.seconds;
    currentTarget = cfg.target;
    targetsLeft = cfg.targetCount;

    // timers for level behaviors
    targetSwitchTimer = 0;
    colorShiftTimer = 0;

    setHUD();
    spawnTiles();

    lastTs = performance.now();
    requestAnimationFrame(loop);
  }

  function showEnd(win) {
    mode = "end";
    endOverlay.classList.add("show");

    if (win) {
      endTitle.textContent = "‚úÖ Cleared";
      endText.textContent = `You cleared ${currentTarget}. The scent memory is building.`;
      nextBtn.style.display = (levelIndex < LEVELS.length - 1) ? "inline-block" : "none";
    } else {
      endTitle.textContent = "‚è≥ Time / Fade";
      endText.textContent = `Try again. Your brain will try shortcuts (color, pattern, speed).`;
      nextBtn.style.display = "none";
    }
  }

  function getPointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  function isCorrectClick(tile) {
    // must match target word always
    if (tile.text !== currentTarget) return false;

    // in color-correct levels, the tile must also have the canonical color
    if (cfg.mode === "wordPlusColor") {
      const canon = SPICE_CANON_COLORS[currentTarget] || "#B31217";
      return tile.displayColor.toLowerCase() === canon.toLowerCase();
    }

    return true;
  }

  function onPointerDown(ev) {
    if (mode !== "playing") return;

    const { x, y } = getPointerPos(ev);

    // hit topmost tile
    let hitIndex = -1;
    for (let i = tiles.length - 1; i >= 0; i--) {
      const t = tiles[i];
      if (t.alive && !t.popping && t.hit(x, y)) { hitIndex = i; break; }
    }
    if (hitIndex === -1) return;

    const t = tiles[hitIndex];

    if (isCorrectClick(t)) {
      // scent message on correct
      const bank = TARGET_SCENTS[currentTarget] || SPICE_SCENTS[currentTarget] || ["spice ‚Äî memory"];
      showScentMessage(`${currentTarget.toLowerCase()} ‚Äî ${pick(bank)}`);

      t.pop();
      targetsLeft = Math.max(0, targetsLeft - 1);
      setHUD();

      if (targetsLeft <= 0) {
        setTimeout(() => showEnd(true), 520);
      }
    } else {
      flashWrong();
      // penalty: time, but not brutal
      timeLeft = Math.max(0, timeLeft - 2);
      setHUD();
    }
  }

  canvas.addEventListener("pointerdown", onPointerDown);

  beginBtn.addEventListener("click", () => {
    startOverlay.classList.remove("show");
    endOverlay.classList.remove("show");
    beginLevel();
  });

  restartBtn.addEventListener("click", () => {
    endOverlay.classList.remove("show");
    beginLevel();
  });

  nextBtn.addEventListener("click", () => {
    if (levelIndex < LEVELS.length - 1) levelIndex++;
    endOverlay.classList.remove("show");
    startOverlay.classList.add("show");
    setStartCard();
  });

  function maybeDoColorShift(dt) {
    if (!cfg.colorShift) return;

    // shift colors every ~2.3s
    colorShiftTimer += dt;
    if (colorShiftTimer < 2.3) return;
    colorShiftTimer = 0;

    for (const t of tiles) {
      if (!t.alive || t.popping) continue;

      if (cfg.mode === "wordPlusColor") {
        // In shifting levels, even targets might get wrong colors sometimes
        // This creates the ‚Äúchaos‚Äù you described.
        const keepCorrectSometimes = (Math.random() < 0.55);
        if (t.text === currentTarget && keepCorrectSometimes) {
          t.displayColor = SPICE_CANON_COLORS[t.text] || "#B31217";
        } else {
          t.displayColor = pick(NOISE_COLORS);
        }
      } else if (cfg.mode === "colorNoiseWord") {
        t.displayColor = pick(NOISE_COLORS);
      }
    }
  }

  function maybeSwitchTarget(dt) {
    if (!cfg.targetSwitch) return;

    targetSwitchTimer += dt;
    // change target every ~6 seconds
    if (targetSwitchTimer < 6) return;
    targetSwitchTimer = 0;

    // pick among the 3 ‚Äúsignature‚Äù spices so memory builds
    const candidates = ["BERBERE", "HARISSA", "MITMITA"];
    let next = pick(candidates);
    if (next === currentTarget) next = pick(candidates);

    currentTarget = next;
    hint.textContent = cfg.mode === "wordPlusColor"
      ? `Target changed. Tap ${currentTarget} in its correct color.`
      : `Target changed. Tap ${currentTarget}.`;

    // re-tag which tiles are considered targets (word match)
    // and ensure targets draw on top
    for (const t of tiles) {
      t.isTarget = (t.text === currentTarget);
      if (cfg.mode === "wordPlusColor" && t.isTarget) {
        // optionally snap some targets to correct color immediately
        if (Math.random() < 0.7) t.displayColor = SPICE_CANON_COLORS[currentTarget] || "#B31217";
      }
    }
    tiles = [...tiles.filter(t => !t.isTarget), ...tiles.filter(t => t.isTarget)];
    setHUD();
    showScentMessage(`target ‚Äî ${currentTarget.toLowerCase()}`);
  }

  function loop(ts) {
    const rect = canvas.getBoundingClientRect();
    const width = rect.width, height = rect.height;

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    if (mode === "playing") {
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;

      timeVal.textContent = `${Math.ceil(timeLeft)}s`;
      leftVal.textContent = String(targetsLeft);

      // Level behaviors
      maybeDoColorShift(dt);
      maybeSwitchTarget(dt);

      // fail if time runs out
      if (timeLeft <= 0 && targetsLeft > 0) {
        showEnd(false);
        return;
      }

      // fail if any target fully aged out (early levels)
      const useAging = (levelIndex <= 2); // levels 1‚Äì3
      if (useAging) {
        const agedOut = tiles.some(t => t.text === currentTarget && t.alive && !t.popping && t.age >= 1);
        if (agedOut) {
          showEnd(false);
          return;
        }
      }
    }

    // update + draw
    for (const t of tiles) t.update(dt, width, height, cfg.speed);

    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);

    for (const t of tiles) t.draw(ctx);

    if (mode === "playing") requestAnimationFrame(loop);
  }

  // Boot
  resizeCanvas();
  setStartCard();
})();
</script>
</body>
</html>
