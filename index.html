<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spice Interference ‚Äî African Spices</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #0f1720;
    }

    .wrap {
      height: 100%;
      width: min(520px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
    }

    .hud {
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(15, 23, 32, 0.08);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
    }
    .hud-left { display: grid; gap: 2px; }
    .title {
      font-weight: 1000;
      letter-spacing: 0.2px;
      font-size: 14px;
      line-height: 1.1;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.2;
    }
    .hud-right {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      background: rgba(15, 23, 32, 0.06);
      border: 1px solid rgba(15, 23, 32, 0.10);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
    }
    .pill strong { font-weight: 1000; }

    .stage {
      flex: 1 1 auto;
      min-height: 0;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: manipulation;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(255,255,255,0.65);
    }
    .overlay.show { display: flex; }
    .card {
      width: min(520px, 100%);
      background: #ffffff;
      border: 1px solid rgba(15, 23, 32, 0.10);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.12);
    }
    .card h1 {
      margin: 0 0 8px;
      font-size: 18px;
      line-height: 1.15;
      font-weight: 1000;
    }
    .card p {
      margin: 0 0 12px;
      line-height: 1.45;
      font-size: 13px;
      opacity: 0.9;
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 1000;
      cursor: pointer;
      background: #0f1720;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    .flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: rgba(231, 76, 60, 0.12);
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .flash.show { opacity: 1; }

    .scent-message {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: #0f1720;
      color: white;
      padding: 10px 20px;
      border-radius: 40px;
      font-size: 15px;
      font-weight: 500;
      opacity: 0;
      transition: opacity 200ms ease;
      pointer-events: none;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .scent-message.show { opacity: 1; }

    .hint {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.78;
      text-align: center;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="hud-left">
        <div class="title">Spice Interference ‚Äî African Spices</div>
        <div class="subtitle" id="hudSubtitle">Level 1: Find BERBERE</div>
      </div>
      <div class="hud-right">
        <div class="pill">‚è≥ <strong id="timeVal">‚Äî</strong></div>
        <div class="pill">üéØ Left: <strong id="leftVal">‚Äî</strong></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="flash" id="flash"></div>
      <div class="scent-message" id="scentMessage"></div>

      <div class="overlay show" id="startOverlay">
        <div class="card">
          <h1>BERBERE.</h1>
          <p>
            Find BERBERE. Ignore the others.<br>
            Black and white. Only the word matters.<br>
            <br>
            <strong>Each BERBERE carries a different scent memory.</strong><br>
            <br>
            Let them float. Pop the right ones before they fade.
          </p>
          <div class="btnRow">
            <button id="beginBtn" type="button">Start Level 1</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="endOverlay">
        <div class="card">
          <h1 id="endTitle">Done</h1>
          <p id="endText"></p>
          <div class="btnRow">
            <button id="restartBtn" type="button">Play Again</button>
          </div>
        </div>
      </div>

      <div class="hint" id="hint">Pop BERBERE. Each one smells different.</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);

  const hudSubtitle = document.getElementById("hudSubtitle");
  const timeVal = document.getElementById("timeVal");
  const leftVal = document.getElementById("leftVal");
  const startOverlay = document.getElementById("startOverlay");
  const endOverlay = document.getElementById("endOverlay");
  const endTitle = document.getElementById("endTitle");
  const endText = document.getElementById("endText");
  const flash = document.getElementById("flash");
  const scentMessage = document.getElementById("scentMessage");

  document.getElementById("beginBtn").addEventListener("click", () => {
    startOverlay.classList.remove("show");
    beginLevel();
  });
  document.getElementById("restartBtn").addEventListener("click", () => {
    endOverlay.classList.remove("show");
    beginLevel();
  });

  // African spices ‚Äî your exact list
  const SPICE_LIST = [
    "SALT", "GINGER", "BERBERE", "HARISSA", "MITMITA", 
    "TURMERIC", "CLOVE", "UDA", "PIRI PIRI", "MAGGIE", "CUBEB"
  ];

  // Target for level 1
  const TARGET_SPICE = "BERBERE";
  
  // Scent descriptions for BERBERE (varied, to build composite memory)
  const TARGET_SCENTS = [
    "smoky ‚Äî like fire and dried chiles",
    "warm ‚Äî cloves and cinnamon underneath",
    "deep red ‚Äî you can almost see the color",
    "earthy ‚Äî with a kick that builds slowly",
    "complex ‚Äî every bite tastes different",
    "Ethiopia ‚Äî you remember the first time"
  ];

  // Scent descriptions for other spices (used if we expand later)
  const SPICE_SCENTS = {
    "SALT": ["clean ‚Äî like ocean air", "sharp ‚Äî makes you thirsty", "simple ‚Äî but essential"],
    "GINGER": ["sharp ‚Äî stings the nose", "warm ‚Äî almost lemony", "peppery ‚Äî with heat"],
    "HARISSA": ["fiery ‚Äî roasted peppers", "garlic ‚Äî deep and pungent", "north africa ‚Äî in a paste"],
    "MITMITA": ["cardamom forward ‚Äî bright", "clove ‚Äî then heat", "Ethiopian ‚Äî on lamb"],
    "TURMERIC": ["earthy ‚Äî yellow stain", "bitter ‚Äî slightly musty", "warm ‚Äî golden milk"],
    "CLOVE": ["numbing ‚Äî medicinal", "sweet ‚Äî then sharp", "holiday ‚Äî stuck in an orange"],
    "UDA": ["musky ‚Äî like perfume", "smoky ‚Äî grains of selim", "peppery ‚Äî with a twist"],
    "PIRI PIRI": ["citrus ‚Äî then fire", "bright ‚Äî makes you sweat", "Portuguese ‚Äî but African"],
    "MAGGIE": ["umami ‚Äî salty", "childhood ‚Äî in every stew", "cubes ‚Äî crumbled in"],
    "CUBEB": ["peppery ‚Äî but perfumed", "woody ‚Äî like old cabinets", "sharp ‚Äî then fades"]
  };

  const ROUND_SECONDS = 35;
  const TARGET_COUNT = 5; // number of BERBERE words to pop
  const TOTAL_WORDS = 14;

  function rand(a, b) { return Math.random() * (b - a) + a; }
  function randi(a, b) { return Math.floor(rand(a, b + 1)); }
  function pick(arr) { return arr[randi(0, arr.length - 1)]; }

  class WordTile {
    constructor(x, y, fontSize, vx, vy, text, isTarget) {
      this.x = x; this.y = y;
      this.fontSize = fontSize;
      this.vx = vx; this.vy = vy;
      this.text = text;
      this.isTarget = isTarget;
      this.alive = true;
      this.popping = false;
      this.popT = 0;
      
      // Aging mechanic
      this.age = 0; // 0 to 1, 1 = fully faded
      this.ageRate = rand(0.3, 0.8) / 100;
      this.warningGiven = false;
    }

    hit(px, py) {
      ctx.font = `900 ${this.fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      const metrics = ctx.measureText(this.text);
      const width = metrics.width;
      const height = this.fontSize * 1.2;
      
      const left = this.x - width/2;
      const right = this.x + width/2;
      const top = this.y - height/2;
      const bottom = this.y + height/2;
      
      return px >= left && px <= right && py >= top && py <= bottom;
    }

    pop() {
      if (!this.alive || this.popping) return;
      this.popping = true;
      this.popT = 0;
    }

    update(dt, w, h, speedMul=1) {
      if (!this.alive) return;

      if (this.popping) {
        this.popT += dt * 3.2;
        if (this.popT >= 1) this.alive = false;
        return;
      }

      // Age the spice if it's a target (BERBERE)
      if (this.isTarget && this.alive) {
        this.age = Math.min(1, this.age + this.ageRate * dt * 30);
      }

      // Movement
      this.x += this.vx * dt * speedMul;
      this.y += this.vy * dt * speedMul;

      // Bounce off edges
      const metrics = ctx.measureText(this.text);
      const width = metrics.width;
      const height = this.fontSize * 1.2;
      const pad = 10;
      
      if (this.x - width/2 < pad) { this.x = pad + width/2; this.vx *= -1; }
      if (this.x + width/2 > w - pad) { this.x = w - pad - width/2; this.vx *= -1; }
      if (this.y - height/2 < pad) { this.y = pad + height/2; this.vy *= -1; }
      if (this.y + height/2 > h - pad) { this.y = h - pad - height/2; this.vy *= -1; }
    }

    draw(ctx) {
      if (!this.alive) return;

      let scale = 1, alpha = 1;
      if (this.popping) {
        const t = Math.min(1, this.popT);
        scale = 1 - t * 0.9;
        alpha = 1 - t;
      }

      ctx.save();
      ctx.globalAlpha = alpha * (this.isTarget ? (1 - this.age * 0.6) : 1);
      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);

      // Black and white only ‚Äî grayscale
      // Targets age from dark to light, distractors stay dark
      let grayValue = 30; // default dark
      if (this.isTarget) {
        grayValue = Math.floor(30 + (this.age * 180));
      } else {
        grayValue = 40; // slightly lighter so they're readable but distinct
      }
      
      ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
      ctx.font = `900 ${this.fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(this.text, 0, 0);

      // Warning outline for nearly-expired targets
      if (this.isTarget && this.age > 0.7 && !this.warningGiven) {
        ctx.strokeStyle = "rgba(80, 80, 80, 0.4)";
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, 0, 0);
        this.warningGiven = true;
      }

      ctx.restore();
    }
  }

  let mode = "idle";
  let words = [];
  let lastTs = 0;

  let timeLeft = ROUND_SECONDS;
  let targetsLeft = TARGET_COUNT;

  const BASE_SPEED = 28;
  const SPEED_MUL = 1.0;

  function setHUD() {
    hudSubtitle.textContent = `Level 1: Find BERBERE (${targetsLeft} left)`;
    timeVal.textContent = `${Math.ceil(timeLeft)}s`;
    leftVal.textContent = String(targetsLeft);
  }

  function flashWrong() {
    flash.classList.add("show");
    setTimeout(() => flash.classList.remove("show"), 120);
  }

  function showScentMessage(text) {
    scentMessage.textContent = text;
    scentMessage.classList.add("show");
    setTimeout(() => scentMessage.classList.remove("show"), 1400);
  }

  function spawnWords() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    // Build word list: TARGET_COUNT targets, rest distractors from SPICE_LIST
    const wordList = [];
    
    // Add targets
    for (let i = 0; i < TARGET_COUNT; i++) {
      wordList.push(TARGET_SPICE);
    }
    
    // Add distractors (random from SPICE_LIST, excluding target)
    const distractors = SPICE_LIST.filter(s => s !== TARGET_SPICE);
    while (wordList.length < TOTAL_WORDS) {
      wordList.push(pick(distractors));
    }

    // Shuffle
    for (let i = wordList.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [wordList[i], wordList[j]] = [wordList[j], wordList[i]];
    }
    
    // Create words
    const newWords = wordList.map(text => {
      const isTarget = (text === TARGET_SPICE);
      const fontSize = rand(28, 42);
      const x = rand(fontSize, w - fontSize);
      const y = rand(fontSize, h - fontSize);
      const angle = rand(0, Math.PI * 2);
      const speed = rand(BASE_SPEED * 0.7, BASE_SPEED * 1.3);
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      return new WordTile(x, y, fontSize, vx, vy, text, isTarget);
    });

    // Sort so targets are drawn on top
    words = [
      ...newWords.filter(w => !w.isTarget),
      ...newWords.filter(w => w.isTarget)
    ];
  }

  function beginLevel() {
    resizeCanvas();
    mode = "level";
    timeLeft = ROUND_SECONDS;
    targetsLeft = TARGET_COUNT;
    setHUD();
    spawnWords();
    lastTs = performance.now();
    requestAnimationFrame(loop);
  }

  function showEnd(win) {
    mode = "end";
    endOverlay.classList.add("show");
    if (win) {
      endTitle.textContent = "‚úÖ Cleared";
      endText.textContent = `You found all the BERBERE. The smells are building.`;
    } else {
      endTitle.textContent = "‚è≥ Time's up";
      endText.textContent = `Some BERBERE got too old. Try again.`;
    }
  }

  function getPointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  function onPointerDown(ev) {
    if (mode !== "level") return;
    const { x, y } = getPointerPos(ev);

    // Hit topmost word first
    let hitIndex = -1;
    for (let i = words.length - 1; i >= 0; i--) {
      const w = words[i];
      if (w.alive && !w.popping && w.hit(x, y)) { hitIndex = i; break; }
    }
    if (hitIndex === -1) return;

    const w = words[hitIndex];

    if (w.isTarget) {
      // Correct pop ‚Äî show scent message
      const scent = pick(TARGET_SCENTS);
      showScentMessage(`berbere ‚Äî ${scent}`);
      
      w.pop();
      targetsLeft = Math.max(0, targetsLeft - 1);
      setHUD();
      
      if (targetsLeft <= 0) {
        setTimeout(() => showEnd(true), 520);
      }
    } else {
      // Wrong pop ‚Äî penalty
      flashWrong();
      timeLeft = Math.max(0, timeLeft - 2);
      setHUD();
    }
  }

  canvas.addEventListener("pointerdown", onPointerDown);

  function loop(ts) {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    if (mode === "level") {
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;
      timeVal.textContent = `${Math.ceil(timeLeft)}s`;
      leftVal.textContent = String(targetsLeft);

      // Check if any target aged out completely
      const anyAgedOut = words.some(w => w.isTarget && w.alive && w.age >= 1);
      if (anyAgedOut) {
        showEnd(false);
        return;
      }

      if (timeLeft <= 0 && targetsLeft > 0) {
        showEnd(false);
        return;
      }
    }

    for (const w of words) w.update(dt, w, h, SPEED_MUL);

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, w, h);
    
    for (const w of words) w.draw(ctx);

    if (mode === "level") requestAnimationFrame(loop);
  }

  resizeCanvas();
})();
</script>
</body>
</html>

