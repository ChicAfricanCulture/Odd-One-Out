<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spice Interference ‚Äî Words First Prototype</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #0f1720;
    }

    .wrap {
      height: 100%;
      width: min(520px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
    }

    .hud {
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(15, 23, 32, 0.08);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
    }
    .hud-left { display: grid; gap: 2px; }
    .title {
      font-weight: 1000;
      letter-spacing: 0.2px;
      font-size: 14px;
      line-height: 1.1;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.2;
    }
    .hud-right {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      background: rgba(15, 23, 32, 0.06);
      border: 1px solid rgba(15, 23, 32, 0.10);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
    }
    .pill strong { font-weight: 1000; }

    .stage {
      flex: 1 1 auto;
      min-height: 0;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: manipulation;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(255,255,255,0.65);
    }
    .overlay.show { display: flex; }
    .card {
      width: min(520px, 100%);
      background: #ffffff;
      border: 1px solid rgba(15, 23, 32, 0.10);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.12);
    }
    .card h1 {
      margin: 0 0 8px;
      font-size: 18px;
      line-height: 1.15;
      font-weight: 1000;
    }
    .card p {
      margin: 0 0 12px;
      line-height: 1.45;
      font-size: 13px;
      opacity: 0.9;
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 1000;
      cursor: pointer;
      background: #0f1720;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    .flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: rgba(231, 76, 60, 0.12);
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .flash.show { opacity: 1; }

    .hint {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.78;
      text-align: center;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="hud-left">
        <div class="title">Spice Interference ‚Äî Words First</div>
        <div class="subtitle" id="hudSubtitle">Warm-up: pop one bubble</div>
      </div>
      <div class="hud-right">
        <div class="pill">‚è≥ <strong id="timeVal">‚Äî</strong></div>
        <div class="pill">üéØ Left: <strong id="leftVal">‚Äî</strong></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="flash" id="flash"></div>

      <div class="overlay show" id="startOverlay">
        <div class="card">
          <h1>Pop one bubble to calibrate.</h1>
          <p>
            Rule stays constant. Colors are a trap. You win by reading the <strong>scent cue</strong>.
            Your brain will try to use shortcuts anyway.
          </p>
          <div class="btnRow">
            <button id="beginWarmupBtn" type="button">Start Warm-up</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="endOverlay">
        <div class="card">
          <h1 id="endTitle">Result</h1>
          <p id="endText"></p>
          <div class="btnRow">
            <button id="restartBtn" type="button">Play Again</button>
          </div>
        </div>
      </div>

      <div class="hint" id="hint">Collect by scent cue, not by color. (Your brain will still try.)</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);

  const hudSubtitle = document.getElementById("hudSubtitle");
  const timeVal = document.getElementById("timeVal");
  const leftVal = document.getElementById("leftVal");
  const startOverlay = document.getElementById("startOverlay");
  const endOverlay = document.getElementById("endOverlay");
  const endTitle = document.getElementById("endTitle");
  const endText = document.getElementById("endText");
  const flash = document.getElementById("flash");

  document.getElementById("beginWarmupBtn").addEventListener("click", () => {
    startOverlay.classList.remove("show");
    beginWarmup();
  });
  document.getElementById("restartBtn").addEventListener("click", () => {
    endOverlay.classList.remove("show");
    beginWarmup();
  });

  // Beautiful palette, but assigned randomly to bubbles (NOT meaning)
  const COLOR_PALETTE = [
    "#1B4F72", // deep blue
    "#2C3E50", // slate
    "#4E342E", // brown
    "#6A1B1A", // maroon
    "#2E5E4E", // deep green
    "#3B2A6F", // deep purple
    "#0B3D2E", // pine
    "#2D3436", // charcoal
    "#5D3B09"  // deep amber/brown
  ];

  // Spices with scent cues (the real identifiers)
  // IMPORTANT: Target is based on SCENT CUE now.
  const SPICES = [
    { key: "turmeric", name: "TURMERIC", scent: "earthy gold" },
    { key: "ginger",   name: "GINGER",   scent: "sharp warm" },
    { key: "cumin",    name: "CUMIN",    scent: "dusty smoke" },
    { key: "paprika",  name: "PAPRIKA",  scent: "sweet red" },
    { key: "clove",    name: "CLOVE",    scent: "dark sweet" },
    { key: "cinnamon", name: "CINNAMON", scent: "warm wood" },
    { key: "pepper",   name: "BLACK PEPPER", scent: "sharp bite" },
    { key: "cardamom", name: "CARDAMOM", scent: "bright floral" },
    { key: "nutmeg",   name: "NUTMEG",   scent: "warm nut" }
  ];

  // Constant rule for the round: collect scent cue
  const TARGET_SCENT = "earthy gold"; // turmeric cue
  const ROUND_SECONDS = 30;
  const TOTAL_BUBBLES = 12;
  const TARGET_COUNT = 3;

  function rand(a, b) { return Math.random() * (b - a) + a; }
  function randi(a, b) { return Math.floor(rand(a, b + 1)); }
  function pick(arr) { return arr[randi(0, arr.length - 1)]; }

  class Bubble {
    constructor(x, y, r, vx, vy, spice, color, isTarget) {
      this.x = x; this.y = y; this.r = r;
      this.vx = vx; this.vy = vy;
      this.spice = spice;
      this.color = color;          // random aesthetic color
      this.isTarget = isTarget;    // used for draw order
      this.alive = true;
      this.popping = false;
      this.popT = 0;
    }

    hit(px, py) {
      const dx = px - this.x, dy = py - this.y;
      return (dx*dx + dy*dy) <= (this.r*this.r);
    }

    pop() {
      if (!this.alive || this.popping) return;
      this.popping = true;
      this.popT = 0;
    }

    update(dt, w, h, speedMul=1) {
      if (!this.alive) return;

      if (this.popping) {
        this.popT += dt * 3.2;
        if (this.popT >= 1) this.alive = false;
        return;
      }

      this.x += this.vx * dt * speedMul;
      this.y += this.vy * dt * speedMul;

      const pad = 2;
      if (this.x - this.r < pad) { this.x = this.r + pad; this.vx *= -1; }
      if (this.x + this.r > w - pad) { this.x = w - this.r - pad; this.vx *= -1; }
      if (this.y - this.r < pad) { this.y = this.r + pad; this.vy *= -1; }
      if (this.y + this.r > h - pad) { this.y = h - this.r - pad; this.vy *= -1; }
    }

    draw(ctx) {
      if (!this.alive) return;

      let scale = 1, alpha = 1;
      if (this.popping) {
        const t = Math.min(1, this.popT);
        scale = 1 - t * 0.9;
        alpha = 1 - t;
      }

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);

      // Bubble
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.stroke();

      // TEXT: words-first
      // BIG scent cue, small spice name
      const scentSize = Math.max(13, Math.min(18, this.r * 0.34));
      const nameSize  = Math.max(10, Math.min(13, this.r * 0.22));

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = `1000 ${scentSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillText(this.spice.scent.toUpperCase(), 0, -nameSize * 0.25);

      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.font = `900 ${nameSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillText(this.spice.name, 0, scentSize * 0.72);

      ctx.restore();
    }
  }

  let mode = "idle"; // idle | warmup | round | end
  let bubbles = [];
  let lastTs = 0;

  let timeLeft = ROUND_SECONDS;
  let targetsLeft = TARGET_COUNT;

  const BASE_SPEED = 34;
  const SPEED_MUL_ROUND1 = 1.0;

  function setHUDWarmup() {
    hudSubtitle.textContent = "Warm-up: pop one bubble";
    timeVal.textContent = "‚Äî";
    leftVal.textContent = "‚Äî";
  }

  function setHUDRound() {
    hudSubtitle.textContent = `Round 1: Collect "${TARGET_SCENT.toUpperCase()}"`;
    timeVal.textContent = `${Math.ceil(timeLeft)}s`;
    leftVal.textContent = String(targetsLeft);
  }

  function flashWrong() {
    flash.classList.add("show");
    setTimeout(() => flash.classList.remove("show"), 120);
  }

  function spawnBubblesWarmup() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const r = Math.min(w, h) * 0.18;
    const x = w * 0.5;
    const y = h * 0.48;

    bubbles = [
      new Bubble(
        x, y, r,
        rand(-10, 10), rand(-10, 10),
        { name: "POP ME", scent: "tap to begin" },
        pick(COLOR_PALETTE),
        true
      )
    ];
  }

  function spawnBubblesRound() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const targetSpice = SPICES.find(s => s.scent === TARGET_SCENT);
    const distractors = SPICES.filter(s => s.scent !== TARGET_SCENT);

    const minR = Math.max(42, Math.min(56, w * 0.12));
    const maxR = Math.max(52, Math.min(70, w * 0.16));

    const roundSpecs = [];
    for (let i = 0; i < TARGET_COUNT; i++) roundSpecs.push({ spice: targetSpice, isTarget: true });
    while (roundSpecs.length < TOTAL_BUBBLES) {
      roundSpecs.push({ spice: distractors[randi(0, distractors.length - 1)], isTarget: false });
    }

    // Shuffle positions (targets not all together)
    for (let i = roundSpecs.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [roundSpecs[i], roundSpecs[j]] = [roundSpecs[j], roundSpecs[i]];
    }

    // Create bubbles; colors are random and unrelated to spice
    const created = roundSpecs.map(({spice, isTarget}) => {
      const r = rand(minR, maxR);
      const x = rand(r + 6, w - r - 6);
      const y = rand(r + 6, h - r - 6);

      const angle = rand(0, Math.PI * 2);
      const speed = rand(BASE_SPEED * 0.75, BASE_SPEED * 1.25);
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      return new Bubble(x, y, r, vx, vy, spice, pick(COLOR_PALETTE), isTarget);
    });

    // Key: draw targets on top (reduces ‚Äúhidden behind forever‚Äù frustration)
    bubbles = [
      ...created.filter(b => !b.isTarget),
      ...created.filter(b => b.isTarget),
    ];
  }

  function beginWarmup() {
    resizeCanvas();
    mode = "warmup";
    setHUDWarmup();
    spawnBubblesWarmup();
    lastTs = performance.now();
    requestAnimationFrame(loop);
  }

  function beginRound() {
    mode = "round";
    timeLeft = ROUND_SECONDS;
    targetsLeft = TARGET_COUNT;
    setHUDRound();
    spawnBubblesRound();
  }

  function showEnd(win) {
    mode = "end";
    endOverlay.classList.add("show");
    if (win) {
      endTitle.textContent = "‚úÖ Good focus.";
      endText.textContent = `You cleared all "${TARGET_SCENT}" bubbles with ${Math.ceil(timeLeft)}s left.`;
    } else {
      endTitle.textContent = "‚è≥ Time.";
      endText.textContent = `Targets left: ${targetsLeft}. Try again ‚Äî your brain will still try to shortcut by color.`;
    }
  }

  function getPointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  function onPointerDown(ev) {
    if (mode !== "warmup" && mode !== "round") return;
    const { x, y } = getPointerPos(ev);

    // Hit topmost bubble first
    let hitIndex = -1;
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      if (b.alive && !b.popping && b.hit(x, y)) { hitIndex = i; break; }
    }
    if (hitIndex === -1) return;

    const b = bubbles[hitIndex];

    if (mode === "warmup") {
      b.pop();
      hudSubtitle.textContent = "Good. Now focus.";
      setTimeout(() => beginRound(), 650);
      return;
    }

    // Round: target is SCENT cue, not color
    const isCorrect = (b.spice.scent === TARGET_SCENT);

    if (isCorrect) {
      b.pop();
      targetsLeft = Math.max(0, targetsLeft - 1);
      setHUDRound();
      if (targetsLeft <= 0) setTimeout(() => showEnd(true), 520);
    } else {
      flashWrong();
      // small time penalty so wrong clicks matter, but not brutal
      timeLeft = Math.max(0, timeLeft - 1);
      setHUDRound();
      // wrong bubbles stay (so you can't just clear the board)
    }
  }

  canvas.addEventListener("pointerdown", onPointerDown);

  function loop(ts) {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    if (mode === "round") {
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;
      timeVal.textContent = `${Math.ceil(timeLeft)}s`;
      leftVal.textContent = String(targetsLeft);

      if (timeLeft <= 0 && targetsLeft > 0) showEnd(false);
    }

    const speedMul = (mode === "round") ? SPEED_MUL_ROUND1 : 0.55;
    for (const b of bubbles) b.update(dt, w, h, speedMul);

    ctx.clearRect(0, 0, w, h);
    for (const b of bubbles) b.draw(ctx);

    if (mode === "warmup" || mode === "round") requestAnimationFrame(loop);
  }

  resizeCanvas();
})();
</script>
</body>
</html>
