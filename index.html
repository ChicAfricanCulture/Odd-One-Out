<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spice Interference ‚Äî Prototype</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden; /* single-screen, no page scroll */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #0f1720;
    }

    /* Centered mobile-first stage */
    .wrap {
      height: 100%;
      width: min(520px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
    }

    /* HUD */
    .hud {
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(15, 23, 32, 0.08);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
    }
    .hud-left { display: grid; gap: 2px; }
    .title {
      font-weight: 1000;
      letter-spacing: 0.2px;
      font-size: 14px;
      line-height: 1.1;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.2;
    }
    .hud-right {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      background: rgba(15, 23, 32, 0.06);
      border: 1px solid rgba(15, 23, 32, 0.10);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
    }
    .pill strong { font-weight: 1000; }

    /* Canvas fills remaining space */
    .stage {
      flex: 1 1 auto;
      min-height: 0;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: manipulation; /* better mobile taps */
    }

    /* Overlay screens */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(255,255,255,0.65);
    }
    .overlay.show { display: flex; }
    .card {
      width: min(520px, 100%);
      background: #ffffff;
      border: 1px solid rgba(15, 23, 32, 0.10);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.12);
    }
    .card h1 {
      margin: 0 0 8px;
      font-size: 18px;
      line-height: 1.15;
      font-weight: 1000;
    }
    .card p {
      margin: 0 0 12px;
      line-height: 1.45;
      font-size: 13px;
      opacity: 0.9;
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 1000;
      cursor: pointer;
      background: #0f1720;
      color: #fff;
    }
    button:active { transform: translateY(1px); }

    /* Subtle wrong-click flash */
    .flash {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: rgba(231, 76, 60, 0.12);
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .flash.show { opacity: 1; }

    /* Tiny bottom hint text */
    .hint {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 10px;
      font-size: 12px;
      opacity: 0.75;
      text-align: center;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="hud-left">
        <div class="title" id="hudTitle">Spice Interference ‚Äî Prototype</div>
        <div class="subtitle" id="hudSubtitle">Warm-up: pop one bubble</div>
      </div>
      <div class="hud-right">
        <div class="pill">‚è≥ <strong id="timeVal">‚Äî</strong></div>
        <div class="pill">üéØ Left: <strong id="leftVal">‚Äî</strong></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="flash" id="flash"></div>

      <!-- Start / warm-up overlay -->
      <div class="overlay show" id="startOverlay">
        <div class="card">
          <h1>Pop one bubble to calibrate.</h1>
          <p>
            This game is simple on purpose: the rule stays constant.
            Your mind is the difficulty.
          </p>
          <div class="btnRow">
            <button id="beginWarmupBtn" type="button">Start Warm-up</button>
          </div>
        </div>
      </div>

      <!-- End overlay -->
      <div class="overlay" id="endOverlay">
        <div class="card">
          <h1 id="endTitle">Result</h1>
          <p id="endText"></p>
          <div class="btnRow">
            <button id="restartBtn" type="button">Play Again</button>
          </div>
        </div>
      </div>

      <div class="hint" id="hint">Tip: read the name, but your brain will read the scent words too.</div>
    </div>
  </div>

<script>
(() => {
  /***********************
   *  Canvas setup
   ***********************/
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);

  /***********************
   *  UI elements
   ***********************/
  const hudSubtitle = document.getElementById("hudSubtitle");
  const timeVal = document.getElementById("timeVal");
  const leftVal = document.getElementById("leftVal");
  const startOverlay = document.getElementById("startOverlay");
  const endOverlay = document.getElementById("endOverlay");
  const endTitle = document.getElementById("endTitle");
  const endText = document.getElementById("endText");
  const flash = document.getElementById("flash");

  document.getElementById("beginWarmupBtn").addEventListener("click", () => {
    startOverlay.classList.remove("show");
    beginWarmup();
  });

  document.getElementById("restartBtn").addEventListener("click", () => {
    endOverlay.classList.remove("show");
    beginWarmup();
  });

  /***********************
   *  Game data
   ***********************/
  // Dark, saturated bubble colors (high contrast against white)
  const SPICES = [
    { key: "turmeric", name: "TURMERIC", scent: "earthy gold", color: "#2E5E4E" }, // deep green
    { key: "ginger",   name: "GINGER",   scent: "sharp warm",  color: "#3B2A6F" }, // deep purple
    { key: "cumin",    name: "CUMIN",    scent: "dusty smoke", color: "#1B4F72" }, // deep blue
    { key: "paprika",  name: "PAPRIKA",  scent: "sweet red",   color: "#6A1B1A" }, // deep maroon
    { key: "clove",    name: "CLOVE",    scent: "dark sweet",  color: "#2C3E50" }, // slate
    { key: "cinnamon", name: "CINNAMON", scent: "warm wood",   color: "#4E342E" }, // brown
    { key: "pepper",   name: "BLACK PEPPER", scent: "sharp bite", color: "#263238" } // charcoal
  ];

  const TARGET_KEY = "turmeric";
  const ROUND_SECONDS = 30;
  const TOTAL_BUBBLES = 12;
  const TARGET_COUNT = 3;

  /***********************
   *  Bubbles
   ***********************/
  // We‚Äôll draw text in near-black for maximum readability.
  const TEXT_MAIN = "#0B0F14";
  const TEXT_SUB  = "rgba(11,15,20,0.86)";

  function rand(a, b) { return Math.random() * (b - a) + a; }
  function randi(a, b) { return Math.floor(rand(a, b + 1)); }

  class Bubble {
    constructor(x, y, r, vx, vy, spice) {
      this.x = x; this.y = y; this.r = r;
      this.vx = vx; this.vy = vy;
      this.spice = spice;
      this.alive = true;

      // pop animation
      this.popping = false;
      this.popT = 0; // 0..1
    }

    hit(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return (dx*dx + dy*dy) <= (this.r * this.r);
    }

    pop() {
      if (!this.alive || this.popping) return;
      this.popping = true;
      this.popT = 0;
    }

    update(dt, w, h, speedMul=1) {
      if (!this.alive) return;

      if (this.popping) {
        this.popT += dt * 3.2; // pop speed
        if (this.popT >= 1) {
          this.alive = false;
        }
        return;
      }

      this.x += this.vx * dt * speedMul;
      this.y += this.vy * dt * speedMul;

      // bounce (with padding)
      const pad = 2;
      if (this.x - this.r < pad) { this.x = this.r + pad; this.vx *= -1; }
      if (this.x + this.r > w - pad) { this.x = w - this.r - pad; this.vx *= -1; }
      if (this.y - this.r < pad) { this.y = this.r + pad; this.vy *= -1; }
      if (this.y + this.r > h - pad) { this.y = h - this.r - pad; this.vy *= -1; }
    }

    draw(ctx) {
      if (!this.alive) return;

      // pop scale/alpha
      let scale = 1;
      let alpha = 1;
      if (this.popping) {
        // ease-out shrink
        const t = Math.min(1, this.popT);
        scale = 1 - t * 0.9;
        alpha = 1 - t;
      }

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);

      // Circle
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI * 2);
      ctx.fillStyle = this.spice.color;
      ctx.fill();

      // Soft highlight ring (subtle)
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.stroke();

      // Text (high contrast on dark bubble)
      const nameSize = Math.max(12, Math.min(16, this.r * 0.32));
      const scentSize = Math.max(10, Math.min(13, this.r * 0.24));

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = `1000 ${nameSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillText(this.spice.name, 0, -scentSize * 0.35);

      ctx.fillStyle = "rgba(255,255,255,0.88)";
      ctx.font = `800 ${scentSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillText(this.spice.scent, 0, scentSize * 0.85);

      ctx.restore();
    }
  }

  /***********************
   *  Game states
   ***********************/
  let mode = "idle"; // idle | warmup | round | end
  let bubbles = [];
  let lastTs = 0;

  let timeLeft = ROUND_SECONDS;
  let targetsLeft = TARGET_COUNT;

  // For the ‚Äúbubbles screensaver‚Äù feel
  const BASE_SPEED = 34; // px/sec baseline drift
  const SPEED_MUL_ROUND1 = 1.0;

  function setHUDWarmup() {
    hudSubtitle.textContent = "Warm-up: pop one bubble";
    timeVal.textContent = "‚Äî";
    leftVal.textContent = "‚Äî";
  }

  function setHUDRound() {
    hudSubtitle.textContent = "Round 1: Collect TURMERIC";
    timeVal.textContent = `${timeLeft}s`;
    leftVal.textContent = String(targetsLeft);
  }

  function showEnd(win) {
    mode = "end";
    endOverlay.classList.add("show");
    if (win) {
      endTitle.textContent = "‚úÖ Good focus.";
      endText.textContent = `You cleared all TURMERIC bubbles with ${timeLeft}s left.`;
    } else {
      endTitle.textContent = "‚è≥ Time.";
      endText.textContent = `Targets left: ${targetsLeft}. Try again‚Äîyour brain will interfere less with practice.`;
    }
  }

  function flashWrong() {
    flash.classList.add("show");
    setTimeout(() => flash.classList.remove("show"), 120);
  }

  function spawnBubblesWarmup() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const spice = SPICES.find(s => s.key === TARGET_KEY);
    const r = Math.min(w, h) * 0.18; // big warm-up bubble
    const x = w * 0.5;
    const y = h * 0.48;

    bubbles = [
      new Bubble(x, y, r, rand(-10, 10), rand(-10, 10), {
        ...spice,
        // For warmup, make it explicit
        name: "POP ME",
        scent: "tap to begin"
      })
    ];
  }

  function spawnBubblesRound() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const all = SPICES.slice();
    const target = all.find(s => s.key === TARGET_KEY);
    const distractors = all.filter(s => s.key !== TARGET_KEY);

    // Choose bubble sizes for readability on mobile
    const minR = Math.max(42, Math.min(56, w * 0.12));
    const maxR = Math.max(52, Math.min(70, w * 0.16));

    // Create spices list for round
    const roundSpices = [];
    for (let i = 0; i < TARGET_COUNT; i++) roundSpices.push(target);
    while (roundSpices.length < TOTAL_BUBBLES) {
      roundSpices.push(distractors[randi(0, distractors.length - 1)]);
    }

    // Shuffle
    for (let i = roundSpices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [roundSpices[i], roundSpices[j]] = [roundSpices[j], roundSpices[i]];
    }

    // Place bubbles (simple random placement; overlap allowed)
    bubbles = roundSpices.map((sp, idx) => {
      const r = rand(minR, maxR);

      // Keep bubbles mostly in view; allow overlap naturally
      const x = rand(r + 6, w - r - 6);
      const y = rand(r + 6, h - r - 6);

      // Random drift
      const angle = rand(0, Math.PI * 2);
      const speed = rand(BASE_SPEED * 0.75, BASE_SPEED * 1.25);
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;

      return new Bubble(x, y, r, vx, vy, sp);
    });
  }

  function beginWarmup() {
    resizeCanvas();
    mode = "warmup";
    setHUDWarmup();
    spawnBubblesWarmup();
    lastTs = performance.now();
    requestAnimationFrame(loop);
  }

  function beginRound() {
    mode = "round";
    timeLeft = ROUND_SECONDS;
    targetsLeft = TARGET_COUNT;
    setHUDRound();
    spawnBubblesRound();
  }

  /***********************
   *  Input
   ***********************/
  function getPointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left);
    const y = (ev.clientY - rect.top);
    return { x, y };
  }

  function onPointerDown(ev) {
    if (mode !== "warmup" && mode !== "round") return;

    const { x, y } = getPointerPos(ev);

    // Find topmost bubble hit: check from end to start (draw order)
    let hitIndex = -1;
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      if (b.alive && !b.popping && b.hit(x, y)) {
        hitIndex = i;
        break;
      }
    }

    if (hitIndex === -1) return; // no penalty for background taps

    const b = bubbles[hitIndex];

    if (mode === "warmup") {
      b.pop();
      hudSubtitle.textContent = "Good. Now focus.";
      setTimeout(() => {
        beginRound();
      }, 650);
      return;
    }

    // Round logic
    if (b.spice.key === TARGET_KEY) {
      b.pop();
      targetsLeft = Math.max(0, targetsLeft - 1);
      setHUDRound();

      if (targetsLeft <= 0) {
        // win after pop animation has time to feel satisfying
        setTimeout(() => showEnd(true), 550);
      }
    } else {
      // wrong bubble: small penalty, subtle flash
      flashWrong();

      // tiny time penalty (keeps pressure real)
      timeLeft = Math.max(0, timeLeft - 1);
      setHUDRound();

      // optional: pop wrong too? (I recommend NO for fairness; keep it alive)
      // b.pop();
    }
  }

  canvas.addEventListener("pointerdown", onPointerDown);

  /***********************
   *  Loop
   ***********************/
  function loop(ts) {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    // Update
    if (mode === "round") {
      // Countdown
      // We tick timer smoothly so it feels ‚Äúalive‚Äù, then display as whole seconds
      timeLeft -= dt;
      if (timeLeft < 0) timeLeft = 0;

      // Update HUD as integer seconds
      const sec = Math.ceil(timeLeft);
      timeVal.textContent = `${sec}s`;
      leftVal.textContent = String(targetsLeft);

      // If time up and targets remain
      if (timeLeft <= 0 && targetsLeft > 0) {
        showEnd(false);
      }
    }

    const speedMul = (mode === "round") ? SPEED_MUL_ROUND1 : 0.55;

    for (const b of bubbles) {
      b.update(dt, w, h, speedMul);
    }

    // Draw
    ctx.clearRect(0, 0, w, h);

    // Background is white (body), but if you want a tiny warmth:
    // ctx.fillStyle = "#ffffff";
    // ctx.fillRect(0, 0, w, h);

    // Draw bubbles
    for (const b of bubbles) {
      b.draw(ctx);
    }

    // If game running, keep animating
    if (mode === "warmup" || mode === "round") {
      requestAnimationFrame(loop);
    }
  }

  /***********************
   *  Boot
   ***********************/
  resizeCanvas();
  // startOverlay is shown by default
})();
</script>
</body>
</html>
